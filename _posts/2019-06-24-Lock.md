---
layout: post
title: 'java中的锁'
date: 2019-06-24
author: Justd
cover: '/assets/img/2018-9/09-26/ima.jpeg'
tags:  java 面试题 lock  
---
## 公平锁与非公平锁  
并发包中ReentrantLock的创建可以指定构造函数的boolean类型来得到公平锁或者非公平锁，默认是非公平锁   

### 两者区别：  
`公平锁`：在并发环境中，每个线程在获取锁时会先查看此锁维护的等待队列，如果为空，或者当前线程是等待队列中的第一个，就占用锁，否则就会加入到等待队列中，以后会按照FIFO的规则从队列中等待被取到。

`非公平锁`：非公平锁比较粗鲁上来就直接尝试占有锁，如果尝试失败，就在采用类似公平锁的方式在队列中等待被取到。


对于java ReentrantLock而言，通过构造函数指定该锁是否为公平锁，`默认是非公平锁`。非公平锁的优点自安于吞吐量比公平锁大。

对于synchronized而言，也是一种非公平锁


## 可重入锁（递归锁） 
可重入锁又叫递归锁，典型的可重入锁有ReentrantLock/Synchronized。指的是统一鲜橙外层函数获得锁之后，内层度规函数仍然能获取该锁的代码，同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁   
也就是说，线程可以进入任何一个他已经拥有的锁所同步着的代码块。 
```java
    public synchronized void method01(){
        method02();
    }
    public synchronized void method02(){
        
    }
```
如以上代码，如果一个线程拥有method01的锁，那么会自动拥有method02的锁，这样看，可重入锁最大的作用是避免死锁

## 自旋锁  
可参考上篇文章介绍的[CAS的加锁方式](https://yuge.ml/2019/06/06/CAS.html)     
```java
    public final int getAndSetInt(Object var1, long var2, int var4) {
        int var5;
        do {
            var5 = this.getIntVolatile(var1, var2);
        } while(!this.compareAndSwapInt(var1, var2, var5, var4));

        return var5;
    }
``` 

自旋锁是指获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁直至成功为止，没有类似wait的阻塞，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU
