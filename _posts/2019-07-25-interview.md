---
layout: post
title: 'JVM相关'
date: 2019-07-25
author: Justd
cover: '/assets/img/2019-07/coder.jpg'
tags: 面试  java  
---
有关JVM的几个知识点


## 1. 类的生命周期   
   - 创建阶段
     - 为对象分配存储空间
     - 构造对象
     - 从超类到子类对static成员进行初始化
     - 超类成员变量按顺序初始化，调用超类的构造方法  
     - 子类成员变量按顺序初始化，子类构造方法调用
   - 应用阶段
     - 对象至少被一个强引用持有
   - 不可见阶段
     - 程序的执行超出了对象的作用域
     - 对象不再被强引用持有  
   - 不可达阶段
     - 失去GCroot的连接，不可达。
     - 可以作为GC Roots的对象：
       - 栈中引用的对象
       - 本地栈引用的对象
       - 静态变量引用的对象
       - 常量引用的对象 
   - 收集阶段
   - 终结阶段
   - 对象空间重新分配阶段
## 2. ClassLoarder
   类的加载、连接初始化：
   - 加载：查找并加载字节码数据
   - 连接：
     - 验证：确保被加载类的正确性
     - 准备：为类的静态变量分配内存，并初始化默认值
     - 解析：把类中的符号引用转换为直接引用
   - 初始化：为类的静态变量赋予正确的初始值

## 3. 默认三个ClassLoader
   - BootStrap
   - Extension
   - Application

  **加载顺序** ：bootStrap -> Extension -> Application 如果application也没有加载到，则返回给委托的发起者由它到指定的文件或者网络中加载该类。如果还没有加载到，则抛 ClassNotFoundException 

  **原因** ：
    - 避免重复加载
    - 安全：防止用户自定义Java核心api，比如用户自定义一个String，并优先于java核心的String，会导致先加载用户自定义的类，造成安全问题。
## 4. JVM内存结构

   ![jdk1.8版本](/assets/img/2019-07/jvm.png)  
    - 堆：存放对象实例，几乎所有的对象实例都在这里分配内存
    - 虚拟机栈：虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会创建一个栈帧(Stack Frame)用于存储局部变量、操作栈、动态链接、方法出口等信息  
    - 本地方法栈：存放虚拟机使用到的Native方法 
    - 方法区：又叫元空间，1.8后放在物理内存中，存放被虚拟机加载的类的元数据信息，每个类都有自己的元空间，所有的元空间合并到一起就是我们说的元空间
    - 程序计数器：当前线程所执行的字节码的行号指示器

    其中堆/元空间为线程共享内存，其余每个线程都有各自的内存空间。   

