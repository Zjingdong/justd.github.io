---
layout: post
title: 'MySQL之索引系列（二）'
date: 2018-12-05
author: Justd
cover: '/assets/img/2018-12-5/bg.jpg'
tags: MySQL   
---
>有了索引一定会增加查询速度么，如何利用好索引呢    

现在有以下表结构及数据，执行 **`select * from T between 3 and 5`**,需要执行几次树的搜索，会扫描多少行?   
图1    表的结构：   
![表结构](/assets/img/2018-12-5/descT.png)     

图2    表中数据：     
![表中数据](/assets/img/2018-12-5/dataT.png)   

图3    InnoDB的索引组织结构：    
![InnoDB的索引组织结构](/assets/img/2018-12-5/InnoDB.png)    

由图1及图3可知，ID为主键索引，k为非主键索引，K的叶子节点值为主键ID。    
以下是语句的执行过程：   
1. 在k索引树查找k=3的记录，得到ID=300；
2. 根据ID=300查找对应的R3；
3. 在k索引树查找下一个k=5的记录，得到ID=500；   
4. 根据ID=500找到R4；
5. 在k索引树找下一个k=6，不满足，退出。
   
**从非主键索引回到主键索引树搜索的过程，称之为回表**。以上过程中，读了k索引树的三条记录（步骤1、3、5），回表了两次（步骤2、4）。
在引擎内部通过索引k上其实是读了三个记录：k=3、4、5,但是对于MySQL的server层来说，他在找引擎拿到了两条记录(具体查找过程中server与引擎的执行过程见第一章[一条SQL查询语句的执行过程
](https://yuge.ml/2018/11/14/MySQL-select.html))，因此MySQL认为扫描行数为2。具体如何查看扫描行数后面的会介绍。  
了解了回表的过程，下面来看如何优化索引来避免回表   

## 覆盖索引  
上文执行的SQL语句如果是 **`select ID from T where k between 3 and 5`**，只是请求ID值，那么这个值已经存在于k索引树上，已经可以直接提供结果，不需要回表。也就是说，新的SQL中索引k已经 **"覆盖了"** 语句的查询需求，以上称之为覆盖索引。   
**索引覆盖可以减少树的搜索次数，以此来提升查询性能，所以使用覆盖索引是常见的性能优化手段**。    

基于覆盖索引，来看一个新的例子：   
有一个用户表，定义如下：    
``` mysql
CREATE TABLE `tuser` (
`id` INT ( 11 ) NOT NULL,
`id_card` VARCHAR ( 32 ) DEFAULT NULL,
`name` VARCHAR ( 32 ) DEFAULT NULL,
`age` INT ( 11 ) DEFAULT NULL,
`ismale` TINYINT ( 1 ) DEFAULT NULL,
PRIMARY KEY ( `id` ),
KEY `id_card` ( `id_card` ),
KEY `name_age` ( `name`, `age` ) 
) ENGINE = INNODB
``` 
已知通过身份证号是唯一标识，为了满足根据身份证号查到一个用户的所有信息，只需要对身份证号建立索引就够了。在建立一个(id_Card,name)的联合索引，究竟有没有必要？       

如果现在有这样一个高频请求：根据身份证号找到用户的姓名，那么这个联合索引的意义就体现出来了，这个高频的请求能够用到覆盖索引，因为在(id_Card,name)这个联合索引树上直接能根据身份证号查到姓名，不用在拿到主键ID后回表查找整行记录，减少语句的执行时间。
覆盖索引的目的就是尽量能够一次查到需要数据，避免有回表过程。          

## 最左前缀原则    
按照刚刚的需求，为了根据身份证号查到姓名，需要创建(id_card,name)联合索引，如果现在新的需求需要根据身份证号查到家庭住址，总不能再添加一个(id_card,addr)联合索引，为了每一种查询都设计一个索引，显然是不现实的。 这时候应该怎么做呢？     
结论：**B+树这种索引结构，可以利用索引的"最左前缀"来定位记录**。   

//TO-DO


   